% billiards: Program to model collisions between 2d discs
% Copyright (C) 2022  Tom Spencer (tspencerprog@gmail.com)
%
% This file is part of billiards
%
% billiards is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <https://www.gnu.org/licenses/>.

\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{bm}
\usepackage{datetime}

\def\bibsection{\section*{References}} 

% differential operator
\newcommand{\diff}{\textnormal{d}}

\title{Modelling an Ideal Gas}
\author{Tom Spencer}

\begin{document}

\maketitle

\section{Introduction}
We are interested in modelling a two dimensional ideal gas by modelling motions of individual particles that experience elastic collisions. We then hope to extract some interesting physics from such a simulation, such as showing speed distribution is a Maxwell-Boltzmann, computing the heat capacity and show it follows the ideal gas equation. We will first consider a model using non-rotating discs, though we may relax this later.

There are two approaches to such a simulation. A time driven approach is the most simplest, where we advance the simulation forward by a small time increment $\diff t$ and then check for and perform any collisions that took place during $\diff t$. This approach is simple to understand and implement but has some drawbacks, namely:
\begin{itemize}
    \item If we choose too large a time step, fast moving particles can skip over and avoid collisions with other particles
    \item This means a small step must be selected which is then computationally expensive, especially considering most particles aren't colliding
\end{itemize}

However, unlike many N-body simulation, each particle only experiences a force during a collisions, meaning they travel in straight lines in between collisions. This motivates the event-driven approach, where we have a variable time step, jumping from one collision to the next. It can be summarised as:
\begin{itemize}
    \item Determine the next particle to experience a collision and the time $t_1$ it occurs, current time is $t_0$
    \item Advance all particles to the time $t_1$
    \item Perform the collision on the particle (e.g. flip perpendicular component of velocity)
    \item Store particle ID, time of collision, new position and velocity as an event
    \item Repeat
\end{itemize}

This approach has several advantages, we cannot have issues with fast moving particles skipping collisions and we don't have to perform many iterations where no collisions occurred where one larger jump is sufficient. It can also deal with simple forces acting on particles such that their trajectory between collisions is known beforehand, e.g. constant gravity. However it is more complex to implement and cannot deal with more complicated forces, e.g. Newtonian gravity.

We will implement the event-driven approach, first using an inefficient $\mathcal{O}(N^2)$ approach and then seek a more efficient solution.

\section{Theory}

\subsection{Elastic collisions}
In the following, a particle starts at position $\vec{r}_0$ and travels with velocity $\vec{v}$. Its position is therefore given by,
\begin{equation}
    \vec{r}_p(t)
    =
    \vec{r}_0 + \vec{v}t.
\end{equation}

\subsubsection{Collisions with walls}
A wall that starts at a point $\vec{A}$ and ends at $\vec{B}$ can be parameterised as,
\begin{equation}
    \vec{r}_w(s)
    =
    \vec{A} + (\vec{B} - \vec{A}) s,
\end{equation}
with $0 \leq s \leq 1$. There are two ways a particle can collide with a wall. It can either collide with the ends at $\vec{A}$ or $\vec{B}$, or alternatively it can collide with main body of the wall, corresponding to $0 < s < 1$ in the above parametrisation. Initially, we only consider particles in a rectangular box. As such, particles cannot collide with the ends and so we initially only test for the second scenario.

When a particle of radius $R$ collides with the wall, we note the perpendicular distance between the wall and the centre of the particle is precisely $R$. The collision takes place when,
\begin{equation}
\label{eq:wall_collision}
    (\vec{r}_p(t) - \vec{r}_w(s))^2 = R^2,
\end{equation}
and occurs at,
\begin{equation}
    s
    =
    \frac{(\vec{r}_p(t) - \vec{A}) \cdot (\vec{B} - \vec{A})}{|\vec{B} - \vec{A}|^2}.
\end{equation}
Substituting in for $s$, we can rewrite Eq.~\ref{eq:wall_collision} as,
\begin{equation}
    (t\vec{\alpha} + \vec{\beta})^2 = R^2,
\end{equation}
with,
\begin{align}
    \vec{\alpha}
    =
    \vec{v} - (\vec{v} \cdot \vec{\gamma}) \vec{\gamma},
    &&
    \vec{\beta}
    =
    \vec{\delta} - (\vec{\delta} \cdot \vec{\gamma}) \vec{\gamma},
    &&
    \vec{\gamma} = \frac{\vec{B} - \vec{A}}{|\vec{B}-\vec{A}|},
    &&
    \vec{\delta} = \vec{r}_0 - \vec{A}.
\end{align}
This has solutions,
\begin{equation}
\label{eq:wall_collision_sol}
    t
    =
    \frac{1}{\alpha^2}
    \left(
        -\vec{\alpha} \cdot \vec{\beta}
        \pm
        \sqrt{(\vec{\alpha} \cdot \vec{\beta})^2 + \alpha^2(R^2 - \beta^2)}
    \right).
\end{equation}
We are only interested in collisions in the future and so are only interested in the negative root.

All collisions are currently considered to be elastic. When a particle hit a wall, the component of the particle's velocity perpendicular to the wall is simply negated. The particle's velocity therefore changes by,
\begin{align}
    \Delta \vec{v}
    &=
    -2(\vec{v} - (\vec{v} \cdot \vec{\gamma}) \vec{\gamma}), \\
    &=
    -2 \vec{\alpha}.
\end{align}
We may need to be careful to ensure the magnitude of $\vec{v}$ is unchanged.

\subsection{Disc-boundary collisions}
Boundaries are used to split the simulation area into sectors in order to improve efficiency. They are straight lines and described in the same manner as walls. However, a disc-boundary collision occurs when the centre of a disc intersects with the boundary. A disc will collide with a boundary at time,
\begin{equation}
    t
    =
    \frac{\gamma_x (r_{0y} - A_y) - \gamma_y (r_{0x} - A_x)}{v_x \gamma_y - v_y \gamma_x}.
\end{equation}
$t$ must be positive for a collision to occur. Since the boundary endpoints are placed outside the simulation bounds, there is no need to ensure $0 \leq s \leq 1$. We may need to be careful if a disc is travelling along a sector boundary.

\subsubsection{Collisions between discs}
We consider collisions between two discs of masses $m_1$, $m_2$ and radii $R_1$, $R_2$ respectively. Initially we consider elastic collisions and suppose the discs do not rotate. Denoting the position of each particle as $\vec{r}_1(t)$ and $\vec{r}_2(t)$, a collision occurs when,
\begin{equation}
    (\vec{r}_1(t) - \vec{r}_2(t))^2 = (R_1 + R_2)^2.
\end{equation}
This has the same solution as the disc-wall collision case (Eq.~\ref{eq:wall_collision_sol}) but with,
\begin{align}
    \vec{\alpha}
    =
    \vec{v}_1 - \vec{v}_2,
    &&
    \vec{\beta}
    =
    \vec{r}_{01} - \vec{r}_{02},
    &&
    R = R_1 + R_2.
\end{align}
Here $\vec{v}_1$, $\vec{v}_2$ are the velocity and $\vec{r}_{01}$, $\vec{r}_{02}$ are the velocity and initial position of each respective disc. Again we are only interested in the negative solution and require $t>0$ for a future collision.

To determine the result of a collision, we note the force acting on each particle is entirely parallel to $\vec{r}_1 - \vec{r}_2$ at the moment of collision. The component of the velocity of each particle perpendicular to $\vec{r}_1 - \vec{r}_2$ is therefore unchanged by the collision. Determining the components parallel to $\vec{r}_1 - \vec{r}_2$ is then reduced to a one dimensional problem.

In the one dimensional problem, particles have initial velocities $u_1$ and $u_2$. The centre of mass moves with velocity,
\begin{equation}
    w
    =
    \frac{m_1 u_1 + m_2 u_2}{m_1 + m_2}.
\end{equation}
Applying conservation of momentum and energy in the COM frame produces,
\begin{align}
    m_1 v_1 + m_2 v_2 = 0,
    &&
    m_1 (v_1 - w)^2 + m_2 (v_2 - w)^2 = m_1 (u_1 - w)^2 + m_2 (u_2 - w)^2,
\end{align}
where $v_1$ and $v_2$ are the final velocities. Solving these gives,
\begin{align}
    v_1
    =
    \frac{(m_1 - m_2) u_1 + 2m_2 u_2}{m_1 + m_2},
    &&
    v_2
    =
    \frac{2m_1 u_1 + (m_2 - m_1) u_2}{m_1 + m_2}.
\end{align}
Alternatively, the change in velocity is,
\begin{align}
    \Delta v_1
    =
    \frac{2m_2}{m_1 + m_2} (u_2 - u_1),
    &&
    \Delta v_2
    =
    \frac{2m_1}{m_1 + m_2} (u_1 - u_2).
\end{align}

Returning to the two dimensional problem, we have the perpendicular velocity of each disc changes by $\Delta v_1$ and $\Delta v_2$ respectively. Each disc's velocity changes by,
\begin{align}
    \Delta \vec{v}_1
    =
    \frac{2m_2}{m_1 + m_2} \frac{(\vec{u}_2 - \vec{u}_1) \cdot \Delta \vec{r}}{\Delta r^2},
    &&
    \Delta \vec{v}_2
    =
    -\frac{2m_1}{m_1 + m_2} \frac{(\vec{u}_2 - \vec{u}_1) \cdot \Delta \vec{r}}{\Delta r^2}.
\end{align}
$\Delta r = \vec{r}_2 - \vec{r}_1$ is a vector from the centre of disc 1 to disc 2 and has magnitude $R_1 + R_2$. 

\subsection{Insights from statistical physics}

\section{Program structure}
Function for solving collision detection i.e. Eq.~\ref{eq:wall_collision_sol}.

\begin{itemize}
    \item A \texttt{Vec2D} class to represent a 2 dimensional vector.
    \begin{itemize}
        \item Include methods for magnitude, magnitude squared and dot product
    \end{itemize}
    \item A \texttt{Disc} class to represent a disc
    \begin{itemize}
        \item Stores position, velocity, mass and radius
        \item If rotation is implemented, it will also need to include angular velocity and moment of inertia
    \end{itemize}
    \item A \texttt{Wall} class to represent a straight wall a particle can bounce off
    \begin{itemize}
        \item Stores start and end points, $\vec{A}$ and $\vec{B}$ of the wall
        \item Stores a unit vector pointing from the start point to the wall's end point 
    \end{itemize}
    \item An \texttt{Event} class to represent either a disc-wall or disc-disc collision
    \begin{itemize}
        \item Store index of the disc in the simulation's vector of discs, along with time of event, current position and new velocity
    \end{itemize}
    \item A \texttt{Sim} class to represent a simulation
    \begin{itemize}
        \item Vector to store the discs that are in the simulation, both in their current state and their initial state
        \item Vector to store the walls in the simulation
        \item Vector to store the events that occur during the simulation, if desired
        \item Current time of the simulation
        \item A method to advance the simulation by either a given number of events or duration, whichever is reached sooner, should have a member variable to set whether the events should be stored or only the current state should be stored
        \item A setup method to set the simulation as ready to start. In effect, copies the current state to the initial state variable.
    \end{itemize}
\end{itemize}

We also intend to produce a Cython wrapper to run and analyse the results from a simulation in Python. Initially, we'll implement a simple but inefficient algorithm for checking collisions but later we'll do something more advanced.

\subsection{Cython wrapper}
Here we detail the structure of the Cython wrapper and interface to Python.
\begin{itemize}
    \item Cython needs to be told about \texttt{Vec2D}, but it doesn't need a wrapper provided to Python
    \item \texttt{PyDisc} wrapper for \texttt{Disc}. It does not own the memory, that is owned by the C++ \texttt{Sim}.
    \begin{itemize}
        \item Exposes the member variables of a \texttt{Disc} such as mass, radius etc. as properties
        \item Position and velocity should be exposed as \texttt{numpy} arrays wit shape \texttt{(2,)}
        \item Wraps the position method to compute position at time $t$
    \end{itemize}
    \item \texttt{PyWall} wrapper for \texttt{Wall}. It does not own the memory, that is owned by the C++ \texttt{Sim}.
    \begin{itemize}
        \item Exposes the start and end member variables of a \texttt{Wall} as properties, specifically as \texttt{numpy} arrays with shape \texttt{(2,)}
    \end{itemize}
    \item \texttt{PyEvent} wraps \texttt{Event}. It does not own the memory, that is owned by the C++ \texttt{Sim}.
    \begin{itemize}
        \item Exposes the member variables of an \texttt{Event} such as mass, radius etc. as properties
        \item New position and velocity should be exposed as \texttt{numpy} arrays with shape \texttt{(2,)}
        \item Factory static method for creation from a \texttt{PySim} instance and index of event
    \end{itemize}
    \item \texttt{PySim} wrapper for \texttt{Sim}.
    \begin{itemize}
        \item Should expose member variables as properties using python lists
        \item Method \texttt{setup()} to be called before running the simulation but after discs/walls have been added. Ensures the \texttt{Sim} object is internally set up appropriately.
        \item Method \texttt{advance()} to advance the simulation by either a given number of collisions or duration, whichever is reached first.
        \item Methods \texttt{add\_disc()} and \texttt{add\_wall()} for adding discs/walls to the simulation individually
        \item Method \texttt{add\_random\_discs()} for adding discs in bulk randomly in a box, all with the given parameters e.g. mass, radius etc.
        \item Method \texttt{add\_box\_walls()} for adding four walls in the shape of a box, defined by the position of the bottom-left and top-right corners.
        \item Although we expose discs as a python list, for analysis it may be more useful to access properties as \texttt{numpy} arrays. So we'll have a method that accepts certain parameters and returns a dictionary of \texttt{numpy} arrays corresponding to those parameters.
        \item Property \texttt{initial\_state} to return the initial state of the system as a "state dictionary." Returns a dictionary where the keys correspond to names of disc properties (position, velocity, mass, etc.) and values are those properties as \texttt{numpy} arrays.
        \item Property \texttt{current\_state} that behaves the same as \texttt{initial\_state} but returns a state dictionary for the current state of the simulation.
        \item Two generators for replaying the simulation
        \begin{itemize}
            \item These start at the beginning of the simulation and yield the same state dictionary of \texttt{numpy} arrays the properties for \texttt{initial\_state} and \texttt{current\_state} do
            \item The arrays in this dictionary are successively updated by reference
            \item \texttt{replay\_by\_event()} for moving forward from one event to the next
            \item \texttt{replay\_by\_time()} for moving forward at constant time intervals, useful for making an animation
        \end{itemize}
    \end{itemize}
\end{itemize}

\subsection{Initial algorithm}
Initially we'll implement an inefficient $\mathcal{O}(N^2)$ algorithm as follows:
\begin{enumerate}
    \item Store a list of the last event that occurred and any others that occurred at the same time. This could be due to a particle colliding with the corner of a box and colliding with two walls at the same time
    \item Iterate over all possible disc-wall and disc-disc collisions. Find the one with the smallest positive time till collision.
    \item Now we know the next collision, advance all particles (if necessary) to the time of collision
    \item Perform the appropriate type of collision on the disc or discs
    \item Repeat until the maximum number of collisions is reached or maximum duration is reached.
\end{enumerate}
The above doesn't account for what to do if a disc undergoes two collisions at the same time, but it'll be enough to check the basic physics of checking for collisions and performing collisions are done correctly.

\subsection{A more efficient approach}
A more efficient approach is described in \cite{Lubachevsky-1991}. Roughly, for each particle the algorithm keeps track of two events, The last collision the particle experienced and the next scheduled collision in the future. The algorithm iterates by:
\begin{itemize}
    \item Determining the particle with the next scheduled event
    \item Making the scheduled event the most recent event the particle underwent 
    \item Determining the next collision of the particle and scheduling it
    \item If the next collision is disc-disc, appropriately scheduling the partner's new collision
\end{itemize}
The main computational effort is spent in determining the next collision and the next scheduled event. Determining the next time can be found in $\mathcal{O}(\log N)$ using a heap as suggested in \cite{Lubachevsky-1991}, whereas determining the next collision can be improved partitioning space into sectors.

\subsection{Dividing the space into sectors}
In this method, the space the particles occupy is split into sectors, each of which should be large enough to fully contain the disc. Only the sector the disc is currently in and those adjacent to it (8 if using squares) need to be checked to determine the next possible disc-disc collision. Similarly, only sectors adjacent to a wall need to check for disc-wall interactions.

% Bibliography
\bibliographystyle{ieeetr}
\bibliography{bibo}

\end{document}















